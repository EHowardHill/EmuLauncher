MainActivity.kt:
package com.cinemint.emulauncher

import android.annotation.SuppressLint
import android.content.Intent
import android.graphics.Bitmap
import android.graphics.Canvas
import android.graphics.Color
import android.graphics.Rect
import android.os.Bundle
import android.os.Environment
import android.view.KeyEvent
import android.view.SurfaceHolder
import android.view.SurfaceView
import androidx.appcompat.app.AppCompatActivity
import java.io.File
import androidx.core.graphics.createBitmap
import android.media.AudioAttributes
import android.media.AudioFormat
import android.media.AudioManager
import android.media.AudioTrack
import android.net.Uri
import android.os.Build
import android.provider.Settings
import androidx.core.net.toUri

class MainActivity : AppCompatActivity(), SurfaceHolder.Callback {

    // --- JNI & Constants ---
    external fun setInputState(buttonId: Int, pressed: Boolean)
    external fun loadCore(path: String): Boolean
    external fun loadGame(path: String): Boolean
    external fun runFrame(bitmap: Bitmap, audioBuffer: ShortArray): Int

    private var audioTrack: AudioTrack? = null
    private val sampleRate = 44100

    companion object {
        init { System.loadLibrary("native-lib") }
        // ... (Button Constants kept the same) ...
        const val BUTTON_B = 0; const val BUTTON_Y = 1; const val BUTTON_SELECT = 2
        const val BUTTON_START = 3; const val BUTTON_UP = 4; const val BUTTON_DOWN = 5
        const val BUTTON_LEFT = 6; const val BUTTON_RIGHT = 7; const val BUTTON_A = 8
        const val BUTTON_X = 9; const val BUTTON_L = 10; const val BUTTON_R = 11
    }

    // --- Performance Optimization: Allocation ---
    // We create these ONCE. Reusing them prevents Garbage Collection stutter.
    private val emuBitmap = createBitmap(240, 160, Bitmap.Config.RGB_565)
    private val audioBuffer = ShortArray(4096)

    // --- Threading & View ---
    private lateinit var surfaceView: SurfaceView
    private var gameThread: Thread? = null
    @Volatile private var isRunning = false
    private var coreIsReady = false

    @SuppressLint("ClickableViewAccessibility")
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.main_activity)

        surfaceView = findViewById(R.id.emu_surface)
        surfaceView.holder.addCallback(this)

        // No permission checks needed! Just start.
        Thread { setupEmulator() }.start()
    }

    private fun setupEmulator() {
        val corePath = applicationInfo.nativeLibraryDir + "/libmgba.so"

        // The destination file in the app's private cache
        val internalFile = File(cacheDir, "game.gba")

        try {
            // ALWAYS extract the file from the APK to ensure we have the latest version
            // (Overwriting is fast enough for a single ROM)
            resources.openRawResource(R.raw.rom).use { input ->
                internalFile.outputStream().use { output ->
                    input.copyTo(output)
                }
            }
            println("ROM extracted from APK to: ${internalFile.absolutePath}")

            // Load Core and Game
            if (loadCore(corePath) && loadGame(internalFile.absolutePath)) {
                coreIsReady = true
                println("Core Loaded & Ready. Waiting for Surface...")

                val holder = surfaceView.holder
                if (holder.surface.isValid) {
                    startGameLoop(holder)
                }
            } else {
                println("Failed to load core or game.")
            }
        } catch (e: Exception) {
            e.printStackTrace()
            println("Error extracting or loading ROM: ${e.message}")
        }
    }

    override fun surfaceCreated(holder: SurfaceHolder) {
        // Only start if the core is actually ready.
        // If not, setupEmulator() will call startGameLoop() when it finishes.
        if (coreIsReady) {
            startGameLoop(holder)
        }
    }

    override fun surfaceChanged(holder: SurfaceHolder, format: Int, width: Int, height: Int) {}

    override fun surfaceDestroyed(holder: SurfaceHolder) {
        // App paused or closed. Stop the thread to save battery/crashes.
        stopGameLoop()
    }

    // --- The Game Loop ---

    private fun startGameLoop(holder: SurfaceHolder) {
        if (isRunning) return
        isRunning = true

        // --- Initialize AudioTrack ---
        // Calculate the minimum buffer size required by Android
        val minBufferSize = AudioTrack.getMinBufferSize(
            sampleRate,
            AudioFormat.CHANNEL_OUT_STEREO,
            AudioFormat.ENCODING_PCM_16BIT
        )

        // Create the track
        // Note: usage of AudioTrack constructor depends on Android version,
        // this is the modern builder approach (API 23+)
        audioTrack = AudioTrack.Builder()
            .setAudioAttributes(
                AudioAttributes.Builder()
                    .setUsage(AudioAttributes.USAGE_GAME)
                    .setContentType(AudioAttributes.CONTENT_TYPE_MUSIC)
                    .build()
            )
            .setAudioFormat(
                AudioFormat.Builder()
                    .setEncoding(AudioFormat.ENCODING_PCM_16BIT)
                    .setSampleRate(sampleRate)
                    .setChannelMask(AudioFormat.CHANNEL_OUT_STEREO)
                    .build()
            )
            .setTransferMode(AudioTrack.MODE_STREAM)
            .setBufferSizeInBytes(minBufferSize)
            .build()

        // IMPORTANT: You must call play() or it will silently accept data but make no sound
        audioTrack?.play()

        gameThread = Thread {
            val destRect = Rect()

            while (isRunning) {
                val startTime = System.nanoTime()

                // 3. Run Frame & Get Audio Count
                val samplesGenerated = runFrame(emuBitmap, audioBuffer)

                // 4. Draw Video
                val canvas: Canvas? = holder.lockCanvas()
                if (canvas != null) {
                    try {
                        if (destRect.isEmpty || destRect.width() != canvas.width) {
                            destRect.set(0, 0, canvas.width, canvas.height)
                        }
                        canvas.drawColor(Color.BLACK)
                        canvas.drawBitmap(emuBitmap, null, destRect, null)
                    } finally {
                        holder.unlockCanvasAndPost(canvas)
                    }
                }

                // 5. Write Audio
                // Only write if we actually have samples
                if (samplesGenerated > 0) {
                    // write() is blocking by default, ensuring we don't run too fast
                    audioTrack?.write(audioBuffer, 0, samplesGenerated)
                }

                // 6. Frame Pacing (Optional but Recommended)
                // AudioTrack.write acts as a throttle (it blocks if full),
                // but a small sleep helps CPU usage if audio buffer is large.
                val processTimeMs = (System.nanoTime() - startTime) / 1_000_000
                val sleepTime = 16 - processTimeMs
                if (sleepTime > 0) {
                    try { Thread.sleep(sleepTime) } catch (e: InterruptedException) { }
                }
            }

            // Clean up when loop ends
            audioTrack?.stop()
            audioTrack?.release()
            audioTrack = null

        }.apply { start() }
    }

    private fun stopGameLoop() {
        isRunning = false
        try {
            gameThread?.join() // Wait for thread to finish safely
        } catch (e: InterruptedException) {
            e.printStackTrace()
        }
        gameThread = null
    }

    // --- Input Handling ---
    override fun dispatchKeyEvent(event: KeyEvent): Boolean {
        val isDown = event.action == KeyEvent.ACTION_DOWN

        val gbaButton = when (event.keyCode) {
            // --- Game Controller (Standard) ---
            KeyEvent.KEYCODE_BUTTON_A, KeyEvent.KEYCODE_BUTTON_X -> BUTTON_A
            KeyEvent.KEYCODE_BUTTON_B, KeyEvent.KEYCODE_BUTTON_Y -> BUTTON_B
            KeyEvent.KEYCODE_BUTTON_L1 -> BUTTON_L
            KeyEvent.KEYCODE_BUTTON_R1 -> BUTTON_R
            KeyEvent.KEYCODE_BUTTON_START -> BUTTON_START
            KeyEvent.KEYCODE_BUTTON_SELECT -> BUTTON_SELECT

            // --- Keyboard: Face Buttons & Triggers ---
            KeyEvent.KEYCODE_Z -> BUTTON_A          // Z = A
            KeyEvent.KEYCODE_X -> BUTTON_B          // X = B
            KeyEvent.KEYCODE_A -> BUTTON_L          // A = Left Shoulder (Trigger)
            KeyEvent.KEYCODE_S -> BUTTON_R          // S = Right Shoulder (Trigger)
            KeyEvent.KEYCODE_ENTER -> BUTTON_START  // Enter = Start
            KeyEvent.KEYCODE_DEL -> BUTTON_SELECT   // Backspace = Select

            // --- Keyboard: Navigation (Arrows Only) ---
            KeyEvent.KEYCODE_DPAD_UP -> BUTTON_UP
            KeyEvent.KEYCODE_DPAD_DOWN -> BUTTON_DOWN
            KeyEvent.KEYCODE_DPAD_LEFT -> BUTTON_LEFT
            KeyEvent.KEYCODE_DPAD_RIGHT -> BUTTON_RIGHT

            else -> return super.dispatchKeyEvent(event)
        }

        setInputState(gbaButton, isDown)
        return true
    }
}