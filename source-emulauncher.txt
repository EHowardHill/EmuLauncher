EmulatorActivity.kt:
package com.cinemint.emulauncher

import android.annotation.SuppressLint
import android.graphics.Bitmap
import android.graphics.Canvas
import android.graphics.Rect
import android.media.AudioAttributes
import android.media.AudioFormat
import android.media.AudioManager
import android.media.AudioTrack
import android.net.Uri
import android.os.Build
import android.os.Bundle
import android.view.InputDevice
import android.view.KeyEvent
import android.view.MotionEvent
import android.view.SurfaceHolder
import android.view.SurfaceView
import android.view.View
import androidx.annotation.RequiresApi
import androidx.appcompat.app.AppCompatActivity
import androidx.core.graphics.createBitmap
import java.io.File
import java.io.FileOutputStream

class EmulatorActivity : AppCompatActivity(), SurfaceHolder.Callback {

    // --- JNI Methods ---
    external fun setInputState(buttonId: Int, pressed: Boolean)
    external fun loadCore(path: String): Boolean
    external fun loadGame(path: String): Boolean
    external fun runFrame(bitmap: Bitmap, audioBuffer: ShortArray): Int
    external fun getCoreSampleRate(): Double

    // --- Audio & Video ---
    private var audioTrack: AudioTrack? = null
    // 66117 was your hardcoded rate, but we will calculate the exact sync rate dynamically
    private val emuBitmap = createBitmap(240, 160, Bitmap.Config.RGB_565)
    private val audioBuffer = ShortArray(4096)

    private lateinit var surfaceView: SurfaceView
    private var gameThread: Thread? = null
    @Volatile private var isRunning = false
    private var coreIsReady = false

    companion object {
        init { System.loadLibrary("native-lib") }

        // Standard Libretro Button Map
        const val BUTTON_B = 0
        const val BUTTON_Y = 1
        const val BUTTON_SELECT = 2
        const val BUTTON_START = 3
        const val BUTTON_UP = 4
        const val BUTTON_DOWN = 5
        const val BUTTON_LEFT = 6
        const val BUTTON_RIGHT = 7
        const val BUTTON_A = 8
        const val BUTTON_X = 9
        const val BUTTON_L = 10
        const val BUTTON_R = 11
        const val BUTTON_L2 = 12
        const val BUTTON_R2 = 13
        const val BUTTON_L3 = 14
        const val BUTTON_R3 = 15
    }

    @RequiresApi(Build.VERSION_CODES.O)
    @SuppressLint("ClickableViewAccessibility")
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.emulator_activity)

        surfaceView = findViewById(R.id.emu_surface)
        surfaceView.holder.addCallback(this)

        // 1. Get Data from Intent (Passed from MainActivity)
        val romUri: Uri? = intent.data
        val romName: String = intent.getStringExtra("FILE_NAME") ?: "rom.gba"

        // 2. Check for physical controllers
        if (!hasPhysicalController()) {
            setupGbaTouchControls()
        } else {
            // Hide touch controls if physical controller is present
            findViewById<View>(R.id.touch_overlay).visibility = View.GONE
        }

        // 3. Start setup in a background thread (File I/O is heavy)
        Thread { setupEmulator(romUri, romName) }.start()
    }

    // --- Controller Detection ---
    private fun hasPhysicalController(): Boolean {
        val ids = InputDevice.getDeviceIds()
        for (id in ids) {
            val dev = InputDevice.getDevice(id) ?: continue
            val sources = dev.sources

            // Check for Gamepad or Joystick
            val isGamepad = (sources and InputDevice.SOURCE_GAMEPAD) == InputDevice.SOURCE_GAMEPAD
            val isJoystick = (sources and InputDevice.SOURCE_JOYSTICK) == InputDevice.SOURCE_JOYSTICK

            if (isGamepad || isJoystick) {
                return true
            }
        }
        return false
    }

    // --- Touch Control Setup (Multitouch Support) ---
    @SuppressLint("ClickableViewAccessibility")
    private fun setupGbaTouchControls() {
        val overlay = findViewById<View>(R.id.touch_overlay)
        overlay.visibility = View.VISIBLE

        // 1. Standard Bind for standalone buttons
        fun bind(viewId: Int, emuBtn: Int) {
            findViewById<View>(viewId).setOnTouchListener { v, event ->
                when (event.action) {
                    MotionEvent.ACTION_DOWN -> {
                        v.isPressed = true
                        setInputState(emuBtn, true)
                    }
                    MotionEvent.ACTION_UP, MotionEvent.ACTION_CANCEL -> {
                        v.isPressed = false
                        setInputState(emuBtn, false)
                    }
                }
                true
            }
        }

        bind(R.id.btn_a, BUTTON_A)
        bind(R.id.btn_b, BUTTON_B)
        bind(R.id.btn_start, BUTTON_START)
        bind(R.id.btn_select, BUTTON_SELECT)
        bind(R.id.btn_l, BUTTON_L)
        bind(R.id.btn_r, BUTTON_R)

        // 2. D-Pad Multitouch Logic
        val dpadContainer = findViewById<View>(R.id.dpad_container)
        val btnUp = findViewById<View>(R.id.btn_up)
        val btnDown = findViewById<View>(R.id.btn_down)
        val btnLeft = findViewById<View>(R.id.btn_left)
        val btnRight = findViewById<View>(R.id.btn_right)

        // Helper: Checks if coordinates are inside a view
        fun isTouchInsideView(view: View, x: Float, y: Float): Boolean {
            val rect = Rect()
            view.getHitRect(rect)
            return rect.contains(x.toInt(), y.toInt())
        }

        // State tracking
        var lastUp = false
        var lastDown = false
        var lastLeft = false
        var lastRight = false

        dpadContainer.setOnTouchListener { _, event ->
            var isUp = false
            var isDown = false
            var isLeft = false
            var isRight = false

            val action = event.actionMasked
            if (action != MotionEvent.ACTION_UP && action != MotionEvent.ACTION_CANCEL) {
                // Iterate through all pointers (fingers)
                for (i in 0 until event.pointerCount) {
                    if (action == MotionEvent.ACTION_POINTER_UP && i == event.actionIndex) continue

                    val x = event.getX(i)
                    val y = event.getY(i)

                    if (isTouchInsideView(btnUp, x, y)) isUp = true
                    if (isTouchInsideView(btnDown, x, y)) isDown = true
                    if (isTouchInsideView(btnLeft, x, y)) isLeft = true
                    if (isTouchInsideView(btnRight, x, y)) isRight = true
                }
            }

            // Update State & JNI
            if (isUp != lastUp) {
                btnUp.isPressed = isUp
                setInputState(BUTTON_UP, isUp)
                lastUp = isUp
            }
            if (isDown != lastDown) {
                btnDown.isPressed = isDown
                setInputState(BUTTON_DOWN, isDown)
                lastDown = isDown
            }
            if (isLeft != lastLeft) {
                btnLeft.isPressed = isLeft
                setInputState(BUTTON_LEFT, isLeft)
                lastLeft = isLeft
            }
            if (isRight != lastRight) {
                btnRight.isPressed = isRight
                setInputState(BUTTON_RIGHT, isRight)
                lastRight = isRight
            }

            true
        }
    }

    // --- Emulator Setup (File Copy + Core Loading) ---
    @RequiresApi(Build.VERSION_CODES.O)
    private fun setupEmulator(romUri: Uri?, romName: String) {
        // Define target file in internal cache
        val internalFile = File(cacheDir, romName)

        try {
            // 1. Copy file from Content URI to Cache
            if (romUri != null) {
                contentResolver.openInputStream(romUri)?.use { input ->
                    FileOutputStream(internalFile).use { output ->
                        input.copyTo(output)
                    }
                }
            } else if (!internalFile.exists()) {
                // Fallback: Legacy res/raw extraction
                println("No URI provided. Checking for legacy raw resource...")
                val rawResName = internalFile.nameWithoutExtension.lowercase().replace("[^a-z0-9_]".toRegex(), "_")
                val resourceId = resources.getIdentifier(rawResName, "raw", packageName)
                if (resourceId != 0) {
                    resources.openRawResource(resourceId).use { input ->
                        internalFile.outputStream().use { output -> input.copyTo(output) }
                    }
                }
            }

            if (!internalFile.exists()) {
                println("Error: ROM file could not be created or found.")
                return
            }

            // 2. Select Core based on Extension
            val fileName = internalFile.name
            val coreLibName = when {
                // Nintendo
                fileName.endsWith(".nes", true) || fileName.endsWith(".fds", true) -> "libfceumm.so"
                fileName.endsWith(".sfc", true) || fileName.endsWith(".smc", true) -> "libsnes9x.so"
                fileName.endsWith(".gb", true) || fileName.endsWith(".gbc", true) || fileName.endsWith(".dmg", true) -> "libgambatte.so"
                fileName.endsWith(".gba", true) -> "libmgba.so"
                fileName.endsWith(".n64", true) || fileName.endsWith(".z64", true) -> "libmupen64plus_next.so"
                fileName.endsWith(".nds", true) -> "libmelonds.so"
                fileName.endsWith(".vb", true) -> "libmednafen_vb.so"

                // Sega
                fileName.endsWith(".sms", true) || fileName.endsWith(".gg", true) || fileName.endsWith(".md", true) || fileName.endsWith(".gen", true) -> "libgenesis_plus_gx.so"
                fileName.endsWith(".gdi", true) || fileName.endsWith(".cdi", true) -> "libflycast.so"
                fileName.endsWith(".sat", true) -> "libmednafen_saturn.so"

                // Sony
                fileName.endsWith(".pbp", true) || fileName.endsWith(".chd", true) -> "libswanstation.so"
                fileName.endsWith(".iso", true) || fileName.endsWith(".cso", true) -> "libppsspp.so"

                // Arcade/Other
                fileName.endsWith(".zip", true) || fileName.endsWith(".7z", true) -> "libfbneo.so"
                fileName.endsWith(".pce", true) || fileName.endsWith(".sgx", true) -> "libmednafen_pce_fast.so"
                fileName.endsWith(".a26", true) -> "libstella.so"
                fileName.endsWith(".ws", true) || fileName.endsWith(".wsc", true) -> "libmednafen_wswan.so"
                fileName.endsWith(".ngp", true) || fileName.endsWith(".ngc", true) -> "libmednafen_ngp.so"

                // Fallback
                fileName.endsWith(".cue", true) || fileName.endsWith(".bin", true) -> "libswanstation.so"

                else -> {
                    println("Error: Unknown ROM type for $fileName")
                    return
                }
            }

            val corePath = applicationInfo.nativeLibraryDir + "/" + coreLibName

            println("ROM Path: ${internalFile.absolutePath}")
            println("Core Path: $corePath")

            // 3. Load JNI
            if (loadCore(corePath) && loadGame(internalFile.absolutePath)) {
                coreIsReady = true
                val holder = surfaceView.holder
                if (holder.surface.isValid) {
                    startGameLoop(holder)
                }
            } else {
                println("Failed to load core ($coreLibName) or game.")
            }

        } catch (e: Exception) {
            e.printStackTrace()
        }
    }

    // --- SurfaceHolder Callbacks ---
    @RequiresApi(Build.VERSION_CODES.O)
    override fun surfaceCreated(holder: SurfaceHolder) {
        holder.setFixedSize(240, 160)
        if (coreIsReady) {
            startGameLoop(holder)
        }
    }

    override fun surfaceChanged(holder: SurfaceHolder, format: Int, width: Int, height: Int) {}

    override fun surfaceDestroyed(holder: SurfaceHolder) {
        stopGameLoop()
    }

    // --- Game Loop (Audio/Video Sync) ---
    @RequiresApi(Build.VERSION_CODES.O)
    private fun startGameLoop(holder: SurfaceHolder) {
        if (isRunning) return
        isRunning = true

        // 1. Get native core rate (e.g., 32768 or 44100)
        val coreBaseRate = getCoreSampleRate()

        // 2. Calculate Sync Rate
        // CoreRate * (AndroidScreenHz / EmuHz)
        // Usually: CoreRate * (60.0 / 59.97) -> speeds up audio slightly to fill buffer
        val syncSampleRate = (coreBaseRate * (60.0 / 59.7275)).toInt()

        println("Core Rate: $coreBaseRate | Synced Rate: $syncSampleRate")

        // 3. Init AudioTrack
        val minBufferSize = AudioTrack.getMinBufferSize(
            syncSampleRate,
            AudioFormat.CHANNEL_OUT_STEREO,
            AudioFormat.ENCODING_PCM_16BIT
        )

        audioTrack = AudioTrack.Builder()
            .setAudioAttributes(
                AudioAttributes.Builder()
                    .setUsage(AudioAttributes.USAGE_GAME)
                    .setContentType(AudioAttributes.CONTENT_TYPE_MUSIC)
                    .build()
            )
            .setAudioFormat(
                AudioFormat.Builder()
                    .setEncoding(AudioFormat.ENCODING_PCM_16BIT)
                    .setSampleRate(syncSampleRate) // Use calculated rate!
                    .setChannelMask(AudioFormat.CHANNEL_OUT_STEREO)
                    .build()
            )
            .setTransferMode(AudioTrack.MODE_STREAM)
            .setBufferSizeInBytes(minBufferSize)
            .setPerformanceMode(AudioTrack.PERFORMANCE_MODE_LOW_LATENCY)
            .build()

        audioTrack?.play()

        gameThread = Thread {
            var frameCount = 0
            var lastFpsTime = System.currentTimeMillis()

            while (isRunning) {
                // 1. Run Core Frame
                val samplesGenerated = runFrame(emuBitmap, audioBuffer)

                // 2. Draw Video
                val canvas: Canvas? = holder.lockCanvas()
                if (canvas != null) {
                    try {
                        // Draw 1:1 or scaled by SurfaceView automatically
                        canvas.drawBitmap(emuBitmap, 0f, 0f, null)

                        // FPS Calculation (Optional logging)
                        frameCount++
                        val now = System.currentTimeMillis()
                        if (now - lastFpsTime >= 1000) {
                            val fps = frameCount * 1000.0 / (now - lastFpsTime)
                            println("FPS: $fps")
                            frameCount = 0
                            lastFpsTime = now
                        }
                    } finally {
                        holder.unlockCanvasAndPost(canvas)
                    }
                }

                // 3. Play Audio
                if (samplesGenerated > 0) {
                    // Blocking write ensures we don't run too fast (Dynamic Rate Control)
                    audioTrack?.write(audioBuffer, 0, samplesGenerated)
                }

                Thread.yield()
            }

            // Cleanup
            audioTrack?.stop()
            audioTrack?.release()
            audioTrack = null

        }.apply { start() }
    }

    private fun stopGameLoop() {
        isRunning = false
        try { gameThread?.join() } catch (e: InterruptedException) {}
        gameThread = null
    }

    // --- Physical Controller Handling ---
    override fun dispatchKeyEvent(event: KeyEvent): Boolean {
        val isDown = event.action == KeyEvent.ACTION_DOWN

        val retroId = when (event.keyCode) {
            // Face Buttons
            KeyEvent.KEYCODE_Z, KeyEvent.KEYCODE_BUTTON_A -> BUTTON_A
            KeyEvent.KEYCODE_X, KeyEvent.KEYCODE_BUTTON_B -> BUTTON_B
            KeyEvent.KEYCODE_A, KeyEvent.KEYCODE_BUTTON_X -> BUTTON_X
            KeyEvent.KEYCODE_S, KeyEvent.KEYCODE_BUTTON_Y -> BUTTON_Y

            // Shoulders
            KeyEvent.KEYCODE_Q, KeyEvent.KEYCODE_BUTTON_L1 -> BUTTON_L
            KeyEvent.KEYCODE_W, KeyEvent.KEYCODE_BUTTON_R1 -> BUTTON_R
            KeyEvent.KEYCODE_BUTTON_L2 -> BUTTON_L2
            KeyEvent.KEYCODE_BUTTON_R2 -> BUTTON_R2

            // System
            KeyEvent.KEYCODE_ENTER, KeyEvent.KEYCODE_BUTTON_START -> BUTTON_START
            KeyEvent.KEYCODE_DEL, KeyEvent.KEYCODE_BUTTON_SELECT -> BUTTON_SELECT

            // D-Pad
            KeyEvent.KEYCODE_DPAD_UP -> BUTTON_UP
            KeyEvent.KEYCODE_DPAD_DOWN -> BUTTON_DOWN
            KeyEvent.KEYCODE_DPAD_LEFT -> BUTTON_LEFT
            KeyEvent.KEYCODE_DPAD_RIGHT -> BUTTON_RIGHT

            else -> return super.dispatchKeyEvent(event)
        }

        setInputState(retroId, isDown)
        return true
    }
}

MainActivity.kt:
package com.cinemint.emulauncher

import android.Manifest
import android.content.Intent
import android.content.pm.PackageManager
import android.content.pm.ResolveInfo
import android.net.Uri
import android.os.Build
import android.os.Bundle
import android.os.Environment
import android.provider.Settings
import android.view.KeyEvent
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.ImageView
import android.widget.TextView
import android.widget.Toast
import android.media.MediaPlayer
import androidx.appcompat.app.AppCompatActivity
import androidx.core.app.ActivityCompat
import androidx.core.content.ContextCompat
import androidx.recyclerview.widget.LinearLayoutManager
import androidx.recyclerview.widget.LinearSnapHelper
import androidx.recyclerview.widget.RecyclerView
import java.io.File
import kotlin.math.abs
import androidx.core.net.toUri
import android.animation.ArgbEvaluator
import android.animation.ValueAnimator
import android.graphics.Bitmap
import android.graphics.Canvas
import android.graphics.drawable.BitmapDrawable
import android.graphics.drawable.Drawable
import androidx.core.graphics.drawable.toBitmap
import androidx.palette.graphics.Palette
import androidx.core.graphics.createBitmap

class MainActivity : AppCompatActivity() {

    private lateinit var recyclerView: RecyclerView
    private var mediaPlayer: MediaPlayer? = null

    // We keep a reference to the layout manager for scrolling logic
    private lateinit var layoutManager: LinearLayoutManager
    private val contentList = mutableListOf<LauncherItem>()
    private lateinit var adapter: LauncherAdapter

    // Helper to snap items to center
    private val snapHelper = LinearSnapHelper()

    private lateinit var rootLayout: View
    private var currentBackgroundColor: Int = 0xFF121212.toInt()
    private var lastCenterPosition: Int = -1
    private var colorAnimator: ValueAnimator? = null

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.main_activity)

        rootLayout = findViewById(R.id.root_layout)

        mediaPlayer = MediaPlayer.create(this, R.raw.music)
        mediaPlayer?.isLooping = true

        recyclerView = findViewById(R.id.recycler_view)
        layoutManager = LinearLayoutManager(this, LinearLayoutManager.VERTICAL, false)
        recyclerView.layoutManager = layoutManager

        adapter = LauncherAdapter(contentList, packageManager)
        recyclerView.adapter = adapter

        // 1. Attach SnapHelper to force items to stop in the center
        snapHelper.attachToRecyclerView(recyclerView)

        // 2. Add the "Rolodex" Visual Effect
        recyclerView.addOnScrollListener(object : RecyclerView.OnScrollListener() {
            override fun onScrolled(recyclerView: RecyclerView, dx: Int, dy: Int) {
                super.onScrolled(recyclerView, dx, dy)
                applyRolodexEffect()

                // NEW: Check which item is in the center and update color
                checkCenterItemColor()
            }
        })

        // Initial check
        checkPermissionsAndLoad()

        // Apply effect immediately after layout so the initial state looks correct
        recyclerView.post { applyRolodexEffect() }
    }

    private fun checkCenterItemColor() {
        val centerView = snapHelper.findSnapView(layoutManager) ?: return
        val pos = layoutManager.getPosition(centerView)

        // Only trigger animation if the selected item has changed
        if (pos != lastCenterPosition && pos >= 0 && pos < contentList.size) {
            lastCenterPosition = pos
            val targetColor = contentList[pos].color
            animateBackgroundColor(targetColor)
        }
    }

    private fun animateBackgroundColor(toColor: Int) {
        // Cancel any running animation so we don't fight over colors
        colorAnimator?.cancel()

        // Create a new smooth transition
        colorAnimator = ValueAnimator.ofObject(ArgbEvaluator(), currentBackgroundColor, toColor)
        colorAnimator?.duration = 500 // 500ms fade duration
        colorAnimator?.addUpdateListener { animator ->
            val color = animator.animatedValue as Int
            currentBackgroundColor = color // Update our tracker
            rootLayout.setBackgroundColor(color)
            // Optional: You can also darken the color slightly if it's too bright
        }
        colorAnimator?.start()
    }

    // --- The Visual "Rolodex" Math ---
    private fun applyRolodexEffect() {
        val parentCenterY = recyclerView.height / 2f
        val parentHeight = recyclerView.height.toFloat()

        // 1. Loop through children
        for (i in 0 until recyclerView.childCount) {
            val child = recyclerView.getChildAt(i)

            // 2. Calculate the distance from the center
            val childCenterY = (child.top + child.bottom) / 2f
            val distFromCenter = childCenterY - parentCenterY

            // 3. Normalized position: -1 (top) to 0 (center) to 1 (bottom)
            // We divide by half the height to get the range
            val fraction = distFromCenter / (parentHeight / 2f)

            // Clamp strictly between -1 and 1 to prevent weird math at edges
            val clampedFraction = fraction.coerceIn(-1f, 1f)

            // --- A. THE CURVE (Translation X) ---
            // Push items right based on how far they are from center.
            // Using a quadratic curve (x^2) gives a nice round parabolic shape.
            // 400f is the depth of the curve.
            val translationX = (clampedFraction * clampedFraction) * 32f
            child.translationX = translationX

            // --- B. THE WHEEL ROTATION (Rotation X) ---
            // Rotate items around the X axis to look like a drum.
            // -45 degrees at the top, 45 degrees at the bottom.
            val rotationX = -clampedFraction * 5f
            child.rotationX = rotationX

            // --- C. STACKING (Translation Y) ---
            // We pull items closer to the center to stack them.
            // If item is above center (negative fraction), push it DOWN (positive Y).
            // If item is below center (positive fraction), push it UP (negative Y).
            // The factor 0.3f determines how much they overlap.
            val squeezeFactor = 24f
            val translationY = -clampedFraction * squeezeFactor
            child.translationY = translationY

            // --- D. SCALE & ALPHA ---
            val scale = 1f - (abs(clampedFraction) * 0.4f)
            child.scaleX = scale
            child.scaleY = scale

            // Fade out items at the very edges
            child.alpha = 1f - (abs(clampedFraction) * 0.8f)

            // --- E. Z-ORDER (Elevation) ---
            // Crucial for stacking! Closer to center = Higher Z index.
            // We use standard Elevation API (Android 5.0+).
            child.elevation = (1f - abs(clampedFraction)) * 50f
        }
    }

    // --- Keypad / D-Pad Control ---

    override fun dispatchKeyEvent(event: KeyEvent): Boolean {
        if (event.action == KeyEvent.ACTION_DOWN) {
            when (event.keyCode) {
                KeyEvent.KEYCODE_DPAD_DOWN -> {
                    scrollNext()
                    return true
                }
                KeyEvent.KEYCODE_DPAD_UP -> {
                    scrollPrevious()
                    return true
                }
                // Handle "A" button, Enter, or D-Pad Center
                KeyEvent.KEYCODE_BUTTON_A,
                KeyEvent.KEYCODE_DPAD_CENTER,
                KeyEvent.KEYCODE_ENTER -> {
                    launchCenteredItem()
                    return true
                }
            }
        }
        return super.dispatchKeyEvent(event)
    }

    private fun scrollNext() {
        // Find current center view
        val centerView = snapHelper.findSnapView(layoutManager) ?: return
        val pos = layoutManager.getPosition(centerView)
        if (pos < adapter.itemCount - 1) {
            // Smooth scroll to the next position ensures the snap helper catches it
            recyclerView.smoothScrollToPosition(pos + 1)
        }
    }

    private fun scrollPrevious() {
        val centerView = snapHelper.findSnapView(layoutManager) ?: return
        val pos = layoutManager.getPosition(centerView)
        if (pos > 0) {
            recyclerView.smoothScrollToPosition(pos - 1)
        }
    }

    private fun launchCenteredItem() {
        // 1. Find the view currently snapped to the center
        val centerView = snapHelper.findSnapView(layoutManager)

        if (centerView != null) {
            // 2. Get the data position of that view
            val position = layoutManager.getPosition(centerView)
            if (position != RecyclerView.NO_POSITION) {
                // 3. Trigger the launch logic manually
                val item = contentList[position]

                // Add a small visual feedback animation for the press
                centerView.animate().scaleX(1.1f).scaleY(1.1f).setDuration(100).withEndAction {
                    centerView.animate().scaleX(1.0f).scaleY(1.0f).setDuration(100).start()
                }.start()

                when (item) {
                    is LauncherItem.Rom -> launchEmulator(item.file)
                    is LauncherItem.App -> launchApp(item.resolveInfo)
                }
            }
        }
    }

    // --- Boilerplate LifeCycle Methods ---

    override fun onResume() {
        super.onResume()
        if (hasStoragePermission()) loadAllContent()
        if (mediaPlayer?.isPlaying == false) mediaPlayer?.start()
    }

    override fun onPause() {
        super.onPause()
        if (mediaPlayer?.isPlaying == true) mediaPlayer?.pause()
    }

    override fun onDestroy() {
        super.onDestroy()
        mediaPlayer?.release()
        mediaPlayer = null
    }

    private fun checkPermissionsAndLoad() {
        if (hasStoragePermission()) {
            loadAllContent()
        } else {
            requestStoragePermission()
        }
    }

    // --- Loading Logic ---

    private fun loadAllContent() {
        contentList.clear()

        // 1. Load Data
        if (hasStoragePermission()) {
            val roms = getRomList()
            contentList.addAll(roms.map { file ->
                // Assign a color based on extension
                val color = when {
                    file.name.endsWith(".gba") -> 0xFF3F51B5.toInt() // Indigo
                    file.name.endsWith(".nes") -> 0xFFB71C1C.toInt() // Nintendo Red
                    file.name.endsWith(".sfc") -> 0xFF4A148C.toInt() // SNES Purple
                    file.name.endsWith(".md") -> 0xFF212121.toInt()  // Sega Black
                    else -> 0xFF455A64.toInt() // Generic Grey
                }
                LauncherItem.Rom(file, color)
            })
        }

        val apps = getAppList()
        contentList.addAll(apps.map { info ->
            val icon = info.loadIcon(packageManager)
            val extractedColor = getDominantColor(icon)
            LauncherItem.App(info, info.loadLabel(packageManager).toString(), extractedColor)
        })

        // Sort
        contentList.sortWith { o1, o2 ->
            o1.label.lowercase().compareTo(o2.label.lowercase())
        }

        // 2. Notify Adapter
        adapter.notifyDataSetChanged()

        // 3. Force "Selection" of the first item
        recyclerView.post {
            // A. Calculate padding to center the first item perfectly
            // (We assume the item height is roughly 100-150dp, but centering the parent padding is safer)
            val centerPadding = recyclerView.height / 2

            // Set padding so the top item can be pushed down to the center
            // and the bottom item can be pushed up to the center.
            recyclerView.setPadding(0, centerPadding, 0, centerPadding)

            // B. Scroll to the first item (Index 0)
            // Because of the padding, "Position 0" is now visually in the middle of the screen.
            layoutManager.scrollToPositionWithOffset(0, 0)

            // C. Run the visual math immediately
            // This ensures the first item starts "Big" and "Flat" without needing a touch event first.
            applyRolodexEffect()
        }
    }

    private fun getDominantColor(drawable: Drawable): Int {
        val bitmap = drawableToBitmap(drawable)
        val palette = Palette.from(bitmap).generate()

        // Try to get a "Vibrant" color first, fallback to "Muted", then Gray
        return palette.getVibrantColor(
            palette.getDominantColor(0xFF333333.toInt())
        )
    }

    // Helper to convert Vector/Adaptive icons to Bitmap safely
    private fun drawableToBitmap(drawable: Drawable): Bitmap {
        if (drawable is BitmapDrawable) return drawable.bitmap

        val bitmap = createBitmap(
            drawable.intrinsicWidth.coerceAtLeast(1),
            drawable.intrinsicHeight.coerceAtLeast(1)
        )
        val canvas = Canvas(bitmap)
        drawable.setBounds(0, 0, canvas.width, canvas.height)
        drawable.draw(canvas)
        return bitmap
    }

    private fun getRomList(): List<File> {
        val romList = mutableListOf<File>()
        val romsDir = File(Environment.getExternalStorageDirectory(), "ROMs")

        if (!romsDir.exists()) romsDir.mkdirs()

        if (romsDir.exists() && romsDir.isDirectory) {
            romsDir.listFiles()?.forEach { file ->
                if (!file.isDirectory) {
                    val name = file.name.lowercase()
                    if (name.endsWith(".gba") || name.endsWith(".nes") ||
                        name.endsWith(".sfc") || name.endsWith(".md") ||
                        name.endsWith(".iso") || name.endsWith(".zip")) {
                        romList.add(file)
                    }
                }
            }
        }
        return romList
    }

    private fun getAppList(): List<ResolveInfo> {
        val intent = Intent(Intent.ACTION_MAIN, null)
        intent.addCategory(Intent.CATEGORY_LAUNCHER)
        val apps = packageManager.queryIntentActivities(intent, 0)
        return apps.filter { it.activityInfo.packageName != packageName }
    }

    // --- Permissions Logic ---

    private fun hasStoragePermission(): Boolean {
        return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
            Environment.isExternalStorageManager()
        } else {
            ContextCompat.checkSelfPermission(
                this,
                Manifest.permission.WRITE_EXTERNAL_STORAGE
            ) == PackageManager.PERMISSION_GRANTED
        }
    }

    private fun requestStoragePermission() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
            try {
                val intent = Intent(Settings.ACTION_MANAGE_APP_ALL_FILES_ACCESS_PERMISSION)
                intent.addCategory("android.intent.category.DEFAULT")
                intent.data = String.format("package:%s", applicationContext.packageName).toUri()
                startActivity(intent)
            } catch (e: Exception) {
                val intent = Intent(Settings.ACTION_MANAGE_ALL_FILES_ACCESS_PERMISSION)
                startActivity(intent)
            }
        } else {
            ActivityCompat.requestPermissions(
                this,
                arrayOf(Manifest.permission.WRITE_EXTERNAL_STORAGE),
                100
            )
        }
    }

    // --- Launch Logic ---

    fun launchEmulator(file: File) {
        val intent = Intent(this, EmulatorActivity::class.java)
        intent.data = Uri.fromFile(file)
        intent.putExtra("FILE_NAME", file.name)
        startActivity(intent)
    }

    fun launchApp(info: ResolveInfo) {
        val launchIntent = packageManager.getLaunchIntentForPackage(info.activityInfo.packageName)
        if (launchIntent != null) {
            startActivity(launchIntent)
        } else {
            Toast.makeText(this, "Cannot launch this app", Toast.LENGTH_SHORT).show()
        }
    }

    // --- Unified Adapter ---

    inner class LauncherAdapter(
        private val items: List<LauncherItem>,
        private val pm: PackageManager
    ) : RecyclerView.Adapter<LauncherAdapter.ViewHolder>() {

        inner class ViewHolder(view: View) : RecyclerView.ViewHolder(view) {
            val iconView: ImageView = view.findViewById(R.id.rom_icon)
            val nameText: TextView = view.findViewById(R.id.rom_name)

            // Notice: No OnClickListener here anymore!
            // The Activity handles the click via the "A" button logic.
        }

        override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder {
            val view = LayoutInflater.from(parent.context)
                .inflate(R.layout.item_rom, parent, false)
            return ViewHolder(view)
        }

        override fun onBindViewHolder(holder: ViewHolder, position: Int) {
            val item = items[position]

            when (item) {
                is LauncherItem.Rom -> {
                    holder.nameText.text = item.label
                    holder.iconView.setImageResource(android.R.drawable.ic_menu_save)
                    holder.iconView.setBackgroundColor(0xFF333333.toInt())
                }
                is LauncherItem.App -> {
                    holder.nameText.text = item.label
                    holder.iconView.setImageDrawable(item.resolveInfo.loadIcon(pm))
                    holder.iconView.background = null
                }
            }
        }

        override fun getItemCount() = items.size
    }
}

// Data Structure remains the same
sealed class LauncherItem(val label: String, val color: Int) {
    // ROMs get a color based on their console type
    class Rom(val file: File, color: Int) : LauncherItem(file.name, color)

    // Apps get a color extracted from their icon
    class App(val resolveInfo: ResolveInfo, label: String, color: Int)
        : LauncherItem(label, color)
}